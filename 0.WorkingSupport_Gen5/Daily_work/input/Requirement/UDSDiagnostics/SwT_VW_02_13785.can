/*@!Encoding:1252*/
variables
{
  byte hexArray[64];
}
/*
[PO_01_RS_101992]
The function "Diag UDS Processing" shall «perform the following steps on reception of the UDS Service "ReadDataByIdentifierRequest[]" with DID 0xF17C (FAZIT Identification String) with regard to allowed Value Range, Diagnostic Session ID and Security Level  ('PH_DataByIdentifier'):

   - ReadDataByIdentifierResponse[FAZIT Identification String] :=  Measurement value provided by VKMS API Function 'VKMS_announceFazidId'
   - send positive response».
------------------------------------------------------------------------------------------------------------------------------------------------
// @SW release : RC_CUST_DAS_VW_02_SW_U190.01.01
@date : 06 May 2025
@author : Nguyen Loc
@observations :
------------------------------------------------------------------------------------------------------------------------------------------------
@design
CASE 1:
-IF:
	Request DID 0xF17C via "ReadDataByIdentifierRequest[]" 
-THEN:
	- ReadDataByIdentifierResponse[FAZIT Identification String] :=  Measurement value provided by VKMS API Function 'VKMS_announceFazidId'
   	- send positive response».


CASE 2:
-IF:
	Request DID 0xF17C via "ReadDataByIdentifierRequest[]" ends with Error
-THEN:
	-return the NegativeResponseCode: NRC_0x22_ConditionNotCorrect.	

// Request 22 F1 7C will return "FAZIT Identification String' based on  'VKMS_announceFazidId'
*/
testcase SwT_VW_02_13785()
{
	char reportfile[255], cnTemp[255];
	int i,j,sensorID, bit,k;
	char bytes;

	const int NUMBER_OF_TESTCASE =2;
	const int length_VKMS_announceFazidId_hex = 23;
	const int length_VKMS_announceFazidId_ASCII = 23;
	const int LENGHT_4_U8 = 4;
	const int LENGHT_3_U8 = 3;
	const int LENGHT_6_U8 = 6;
	const int LENGHT_8_U8 = 8;
	char HPS_VKMS_announceFazidId_CFG[24];
	int response[NUMBER_OF_TESTCASE]={0x62, 0x7F};
	int response_bytes[23];
	int OTP_data[23];
	int DID[2]={0xF1, 0x7C};
	char variable[255],chTemp[255];
	diagRequest DiagnServi_DiagnSessiContrExtenSessi extended_session;
	diagRequest DiagnServi_ReadDataByIdentCalibData data;
	diagResponse DiagnServi_ReadDataByIdentCalibData data_res;
	snprintf(HPS_VKMS_announceFazidId_CFG,64,"484C562D484C543231313031353233353935393743443131323334");
	/*Information:
		- HPS_VKMS_announceFazidId_CFG have blockid is PRODDATA_ID_VKMS_announceFazidId = 0x03
		- in "...\85_Release\OTP\OTP_5Gx.s3" -> open it with notepad, after that we have format line contain data is "S325 + 4 bytes address    + PRODDATA_DATA_START_INDEX bytes (see below) + Data + check sum"
																										// example:   S325       801FC040         01 07 00001234567890 FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF45 60
																													  S235 + address:0x801FC040 + BlockID = 1, legnth = 7 , data 00 00 12 34 56 78 90 (20bytes ASCII), check sum = 0x60
		- PRODDATA_DATA_START_INDEX
			The data field is structured in the following way:
			Byte 1 - block id. <<-- 
			Byte 2 - length of the usefull data, the rest is padded with 0xFF.
			The data starts after this byte. <<-- Data that you use to check here, please see SSI to see length of your data
			Byte 32 - the CRC byte of the previous 31 bytes.	
	*/
	
	
	
	//********************************************* Preconditions *********************************************
    funcIDE_DeleteAllBP();
    funcIDE_Reset(); 
    funcIDE_Run();
    func_wait(3000);
	set_target();

	sensorID = funcIDE_ReadVariable("Rte_SensorId_SensorId_SensorId");
	snprintf(reportfile, 255, "X:\\30_Reports\\Diag\\SwT_VW_02_13785");
	TestCaseTitle("SwT_VW_02_13785","The function Diag UDS Processing shall «provide the identification value 'VW Data Set Version Number' (DID 0xF17C) via service ReadDataByIdentifierRequest[]  correctly set with HPS_VKMS_announceFazidId_CFG");
	testReportFileName(reportfile);

	
    //******************************************** End Preconditions *****************************************
	for (i=0;i<NUMBER_OF_TESTCASE;i++)
	{
		testStep("+++" , "+++ SECTION: ------------------------------------CASE %d------------------------------------",i+1);
		diagResize(data, 3);
  		diagSetPrimitiveByte(data, 0, 0x22);
  		diagSetPrimitiveByte(data, 1, DID[0]);
  		diagSetPrimitiveByte(data, 2, DID[1]);
     
		funcWinIdea_SetBPSource("DataServices_Data_DiagnServi_TABROW_VWFAZITIdentStrin_Read_ReadData", "if(RTE_E_OK == retVal_u8)");
  		DiagSendRequest(extended_session);
  		func_Wait(1000);
  		DiagSendRequest(data);
  		funcIDE_WaitForHalt(5000); 
		if (1==i)
			funcIDE_WriteVariable("retVal_u8",1);
		else
		{
		  /*ECU Production Plant Number*/
			for (j = 0; j < LENGHT_4_U8; j++) {	
				snprintf(variable, 255, "tmpProductionData_st.HellaSuplierNumber_CFG_au8[%d]", j);
				bit = check_bytes(HPS_VKMS_announceFazidId_CFG, j);
				funcIDE_readVariableandcheck(variable, bit);
				func_wait(100);
			}
			/*ECU Production Plant Number*/
			for (j = 0; j < LENGHT_3_U8; j++) {	
				snprintf(variable, 255, "tmpProductionData_st.HellaPlantNo_CFG_au8[%d]", j);
				bit = check_bytes(HPS_VKMS_announceFazidId_CFG, j+4);
				funcIDE_readVariableandcheck(variable, bit);
				func_wait(100);
			}
			/*ECU Manufacturing Date*/
			for (j = 0; j < 12; j++) {	
				snprintf(variable, 255, "tmpProductionData_st.HellaProductionDate_CFG_au8[%d]", j);
				bit = check_bytes(HPS_VKMS_announceFazidId_CFG, j+7);
				funcIDE_readVariableandcheck(variable, bit);
				func_wait(100);
			}
			/*ECU Production Test System Number*/
			for (j = 0; j < LENGHT_4_U8; j++) {	
				snprintf(variable, 255, "tmpProductionData_st.HellaEolId_CFG_au8[%d]", j);
				bit = check_bytes(HPS_VKMS_announceFazidId_CFG, j+19);
				funcIDE_readVariableandcheck(variable, bit);
				func_wait(100);
			}
			/*Consecutive Supplier Number*/
			for (j = 0; j < LENGHT_4_U8; j++) {	
				snprintf(variable, 255, "tmpProductionData_st.HellaProductionDayNumber_CFG[%d]", j);
				bit = check_bytes(HPS_VKMS_announceFazidId_CFG, j+23);
				funcIDE_readVariableandcheck(variable, bit);
				func_wait(100);
			}
		}	
		funcIDE_DeleteAllBP();
		funcIDE_Run();
		testWaitForDiagResponse(data, 5000);    
		diagGetLastResponse(data_res);
		k=0;
		if (DiagGetPrimitiveByte(data_res, 0)==response[i])
		{
			if (0x62==response[i])
			{
				for (j = 0; j < length_VKMS_announceFazidId_hex; j++) {
					if (9==j||12==j)
					{
					j++; // ignore 0x2E (".")
					}
					if (15==j)
					k=k+6; // j=15 is ProdutionDate, with format yy/mm/dd/hh/minmin/ss -> we ignore 6 bytes displayed hours/min/second.
							bit = check_bytes(HPS_VKMS_announceFazidId_CFG, k);
							if (DiagGetPrimitiveByte(data_res, j+3) == bit)
							{
								snprintf(chTemp, 1024, "Compare OK: DiagResponse byte %d = %X match with byte %d in OTP: %X", j+3, DiagGetPrimitiveByte(data_res, j+3), k, bit );
								teststeppass(chTemp);
							}
							else
							{
								snprintf(chTemp, 1024, "Compare NOK: DiagResponse byte %d = %X match with byte %d in OTP: %X", j+3, DiagGetPrimitiveByte(data_res, j+3), k, bit );
								teststepfail(chTemp);
							}
							func_wait(100);
					k++;
				}
			}
			else
			{
				if (DiagGetPrimitiveByte(data_res, 2) == 0x22)
					teststeppass("NRC22 is received!");

				else
					teststepfail("NRC22 is NOT received!");
			}
		}
		else
		{
			snprintf(chTemp, 1024, "Response %X is received is not match with expected!",DiagGetPrimitiveByte(data_res, 0));
			teststepfail(chTemp);
		}
		funcIDE_DeleteAllBP();
		funcIDE_Reset();
		funcIDE_Run();
		func_Wait(2000);
		
	}
	
	//********************************************* End ******************************************************
    func_testStepSubSection("Clean Testcase");
    funcIDE_DeleteAllBP();
    funcIDE_Reset();
    funcIDE_Run();
    func_Wait(2000);
}
int check_bytes(char data_byte[],int start_byte)
{
	char bytes[255];
	int value;
	substr_cpy(bytes, data_byte, 2 * start_byte, 2, 1024);
	value = HexStringToNumber(bytes);
	return value;
}
void convertAsciiToHex(char asciiStr[])
{
  int i;
  int len;

  // Copy ký t? v௠m?ng hexArray, t?i da 14 ký t?
  len = strlen(asciiStr);
  for (i = 0; i < 64; i++)
  {
    if (i < len)
    {
      hexArray[i] = asciiStr[i]; // Luu ASCII code v௠m?ng
    }
    else
    {
      hexArray[i] = 0x20; // Ch讠kho?ng tr?ng n?u thi?u
    }
  }
}